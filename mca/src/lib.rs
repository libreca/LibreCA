// Copyright 2021 A Veenstra.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or https://www.apache.org/licenses/LICENSE-2.0> or the
// MIT license <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your option. This file may not be copied,
// modified, or distributed except according to those terms.

//! This module contains the [MCA] and various methods for manipulating it.

#![cfg_attr(test, feature(test))]
#![cfg_attr(test, feature(is_sorted))]
#![cfg_attr(test, feature(slice_as_chunks))]
#![allow(incomplete_features)]
#![feature(adt_const_params)]
#![feature(generic_const_exprs)]
#![deny(missing_docs, rustdoc::missing_crate_level_docs, future_incompatible)]

use common::{Id, ValueGenerator, UVec, u_vec};
use sut::Solver;

#[cfg(test)]
mod bench_types;

/// This is the type of the dont-care locations.
pub type DontCareArray = u64;

/// This value represents the dont-care locations for an empty row.
pub const DONT_CARE_FILLED: DontCareArray = !0;

/// This struct represents the Mixed-level Covering Array generated by the algorithm.
#[derive(Clone)]
pub struct MCA<ValueId: Id> {
    /// The actual array.
    pub array: UVec<UVec<ValueId>>,

    /// The dont-care locations for each row. Should be updated for each update to the row.
    pub dont_care_locations: UVec<DontCareArray>,

    /// This vector contains the indices for all rows to be considered during the vertical extension.
    pub vertical_extension_rows: UVec<usize>,

    /// Used when creating new rows. Clone is faster than allocating new vectors.
    pub new_row: UVec<ValueId>,
}

impl<ValueId: Id> MCA<ValueId> {
    /// Create a new MCA with the first *t* columns filled in.
    /// The provided MCA is in colex order.
    ///
    /// # Example
    /// ```
    /// use mca::MCA;
    /// use common::{u_vec, UVec};
    ///
    /// let parameters = u_vec![4, 2, 2, 2];
    ///
    /// let mca: MCA<usize> = MCA::<usize>::new_unconstrained::<usize, 2>(&parameters);
    ///
    /// assert_eq!(mca.array, u_vec![
    ///     u_vec![0, 0, 0, 0], // First row is always all zeros
    ///     u_vec![1, 0, !0, !0],
    ///     u_vec![2, 0, !0, !0],
    ///     u_vec![3, 0, !0, !0],
    ///     u_vec![0, 1, !0, !0],
    ///     u_vec![1, 1, !0, !0],
    ///     u_vec![2, 1, !0, !0],
    ///     u_vec![3, 1, !0, !0],
    /// ]);
    ///
    /// let ls = (!0) << 2; // 0b_1111_1100
    /// assert_eq!(mca.dont_care_locations, u_vec![
    ///     0, ls, ls, ls, ls, ls, ls, ls,
    /// ]);
    /// ```
    pub fn new_unconstrained<
        ParameterId: Id,
        const STRENGTH: usize,
    >(
        parameters: &UVec<ValueId>,
    ) -> MCA<ValueId> where [(); STRENGTH - 1]:, [(); STRENGTH - 2]: {
        let mut capacity: usize = 1;
        for parameter in parameters.iter().take(STRENGTH) {
            capacity *= parameter.as_usize();
        }

        if STRENGTH < parameters.len() {
            capacity += parameters[0].as_usize() * parameters.len() * STRENGTH * STRENGTH * STRENGTH;
        }
        println!("capacity: {}", capacity);
        let mut array = UVec::with_capacity(capacity);
        array.push(u_vec![ValueId::default(); parameters.len()]);

        let mut pc = [ParameterId::default(); STRENGTH - 1];
        for (index, parameter) in pc.iter_mut().enumerate() {
            *parameter = ParameterId::from_usize(index);
        }

        let mut values = u_vec![ValueId::dont_care(); parameters.len()];
        for value in values.iter_mut().take(STRENGTH) {
            *value = ValueId::default();
        }

        let generator = ValueGenerator::<ValueId, STRENGTH>::new(
            parameters,
            STRENGTH - 1,
            &pc,
        );
        while generator.next_vector_inverse(&mut values) {
            array.push(values.clone());
        }

        let mut dont_care_locations = u_vec![DONT_CARE_FILLED << STRENGTH as DontCareArray; array.len()];
        dont_care_locations.reserve(capacity - array.len());
        dont_care_locations[0] = 0;

        MCA {
            array,
            dont_care_locations,
            vertical_extension_rows: UVec::with_capacity(capacity),
            new_row: u_vec![ValueId::dont_care(); parameters.len()],
        }
    }

    /// Create a new MCA with the first *t* columns filled in while respecting the constraints.
    /// The provided MCA is in colex order.
    pub fn new_constrained<
        'a,
        ParameterId: Id,
        S: Solver<'a>,
        const STRENGTH: usize,
    >(
        parameters: &UVec<ValueId>,
        solver: &mut S,
    ) -> MCA<ValueId> where [(); STRENGTH - 1]:, [(); STRENGTH - 2]: {
        let mut capacity: usize = 1;
        for parameter in parameters.iter().take(STRENGTH) {
            capacity *= parameter.as_usize();
        }

        capacity += parameters[0].as_usize() * parameters.len() * STRENGTH * STRENGTH * STRENGTH;
        println!("capacity: {}", capacity);
        let mut array = UVec::with_capacity(capacity);
        array.push(u_vec![ValueId::default(); parameters.len()]);

        let mut pc = [ParameterId::default(); STRENGTH - 1];
        for (index, parameter) in pc.iter_mut().enumerate() {
            *parameter = ParameterId::from_usize(index);
        }

        let mut values = u_vec![ValueId::dont_care(); parameters.len()];
        for value in values.iter_mut().take(STRENGTH) {
            *value = ValueId::default();
        }

        let generator = ValueGenerator::<ValueId, STRENGTH>::new(
            parameters,
            STRENGTH - 1,
            &pc,
        );
        while generator.next_vector_inverse(&mut values) {
            if solver.check_row(&values[..STRENGTH]) {
                array.push(values.clone());
            }
        }

        let mut dont_care_locations = u_vec![DONT_CARE_FILLED << STRENGTH as DontCareArray; array.len()];
        dont_care_locations.reserve(capacity - array.len());
        dont_care_locations[0] = 0;
        MCA {
            array,
            dont_care_locations,
            vertical_extension_rows: UVec::with_capacity(capacity),
            new_row: u_vec![ValueId::dont_care(); parameters.len()],
        }
    }

    /// Create a new MCA with empty components.
    pub fn new_empty() -> Self {
        Self {
            array: UVec::with_capacity(0),
            dont_care_locations: UVec::with_capacity(0),
            vertical_extension_rows: UVec::with_capacity(0),
            new_row: UVec::with_capacity(0),
        }
    }

    /// Set the [MCA::vertical_extension_rows] with all rows that the vertical extension should consider.
    pub fn set_vertical_extension_rows(&mut self, at_parameter: usize) -> DontCareArray {
        // The mask to check for any dont_care in the cells before the at_parameter
        // So if at_parameter is 5: 0b_00011111 (1111_1111 << at_parameter = 1110_0000; !1110_0000 = 0001_1111)
        let locations_mask = !(DONT_CARE_FILLED << at_parameter as DontCareArray);
        debug_assert_eq!(locations_mask & (1 << at_parameter as DontCareArray), 0);
        debug_assert_ne!(locations_mask & (1 << (at_parameter as DontCareArray - 1)), 0);

        self.vertical_extension_rows.clear();
        for (index, locations) in self.dont_care_locations.iter().enumerate() {
            if locations_mask & *locations != 0 {
                self.vertical_extension_rows.push(index);
            }
        }

        locations_mask
    }

    /// Append a row for the given interaction.
    pub fn append_row<ParameterId: Id, const STRENGTH: usize>(
        &mut self,
        at_parameter: usize,
        pc: &[ParameterId; STRENGTH - 1],
        values: &[ValueId; STRENGTH],
        pc_locations: DontCareArray,
    ) where [(); STRENGTH - 1]:, [(); STRENGTH - 2]: {
        self.vertical_extension_rows.push(self.array.len());
        self.dont_care_locations.push(pc_locations);

        let mut new_row = self.new_row.clone();

        for (&parameter_id, &value_id) in pc.iter().zip(values.iter()) {
            debug_assert!(parameter_id.as_usize() < new_row.len());
            new_row[parameter_id.as_usize()] = value_id;
        }

        new_row[at_parameter] = values[STRENGTH - 1];

        self.array.push(new_row);
    }

    /// Run both [MCA::check_locations] and [MCA::check_ve_rows].
    pub fn check_all(&self, at_parameter: usize) -> bool {
        assert!(cfg!(debug_assertions), "This method should only be used for debugging");
        assert!(self.check_locations());
        assert!(self.check_ve_rows(at_parameter));
        true
    }

    /// Check the locations with the rows.
    pub fn check_locations(&self) -> bool {
        assert!(cfg!(debug_assertions), "This method should only be used for debugging");
        for (row, &locations) in self.array.iter().zip(self.dont_care_locations.iter()) {
            assert!(check_locations(row.as_slice(), locations));
        }
        true
    }

    /// Check the current state of the vertical extension rows.
    pub fn check_ve_rows(&self, at_parameter: usize) -> bool {
        assert!(cfg!(debug_assertions), "This method should only be used for debugging");
        if self.dont_care_locations.is_empty() {
            let mut ve_rows = self.vertical_extension_rows.iter();
            for (index, row) in self.array.iter().enumerate() {
                if row[..at_parameter].contains(&ValueId::dont_care()) {
                    let item = ve_rows.next().expect("Row missing in vertical extension rows.");
                    assert_eq!(*item, index, "Mismatch in rows! {} != {}; found {}: {:?} expected {}: {:?}", *item, index, index, &row[..at_parameter], *item, &self.array[*item][..at_parameter]);
                }
            }
            let next = ve_rows.next();
            assert!(
                next.is_none(),
                "Extra rows in vertical extension row list? {:?}: {:?}",
                next,
                &self.array[*next.unwrap()][..at_parameter - 1]
            );
        } else {
            let dont_care_mask = !(DONT_CARE_FILLED << at_parameter as DontCareArray);

            let mut ve_rows = self.vertical_extension_rows.iter();
            for (index, locations) in self.dont_care_locations.iter().enumerate() {
                if dont_care_mask & *locations != 0 {
                    let item = ve_rows
                        .next()
                        .expect("Row missing in vertical extension rows.");
                    assert_eq!(
                        *item,
                        index,
                        "Mismatch in rows! {} != {}; found {}: {:?} expected {}: {:?}",
                        *item,
                        index,
                        index,
                        &self.array[index][..at_parameter - 1],
                        *item,
                        &self.array[*item][..at_parameter - 1]
                    );
                }
            }
            assert!(
                ve_rows.next().is_none(),
                "Extra rows in vertical extension row list?"
            );
        }
        true
    }
}

/// Provide the locations variables for the given PC.
/// The returned tuple contains the mask with and without the current parameter set (respectively).
pub fn pc_to_mask<ParameterId: Id, const STRENGTH: usize>(
    pc: &[ParameterId; STRENGTH - 1],
    at_parameter: usize,
) -> (DontCareArray, DontCareArray) {
    let mut result = 0;
    for parameter in pc.iter() {
        result += 1 << parameter.as_usize() as DontCareArray;
    }
    (result, result + (1 << at_parameter as DontCareArray))
}

// TODO add #[cfg(debug_assertions)]
/// During debugging this method can check the don't care locations of the row.
pub fn check_locations<ValueId: Id>(row: &[ValueId], locations: u64) -> bool {
    assert!(
        cfg!(debug_assertions),
        "This method should only be used for debugging"
    );

    let mut location = 1;
    for value in row {
        assert_eq!(
            if *value == ValueId::dont_care() {
                location
            } else {
                0
            },
            location & locations,
            "{:?} {:b}",
            row.iter()
                .map(|e| if *e == ValueId::dont_care() {
                    "*".to_string()
                } else {
                    e.to_string()
                })
                .collect::<String>(),
            locations
        );
        location <<= 1;
    }
    true
}
